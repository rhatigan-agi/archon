# Archon Example Outputs

These are real artifacts generated by Archon during development, anonymized for public reference.

Each example demonstrates what Archon produces at different phases of the governed workflow.

## The Example: Adding Task Management to Projects

**Intent**: Add a TODO list feature to Projects, requiring both backend API work and frontend UI integration.

This single intent flows through all phases, showing how Archon:
1. Grounds the intent in discovered codebase facts
2. Resolves ambiguity through user input
3. Generates a structured issue with coverage validation
4. Produces sequenced, dependency-aware phases
5. Creates handoff packets for execution

---

## Directory Structure

```
examples/
├── README.md                          # This file
│
├── 01_intent/
│   └── INTENT_007.json                # The starting point
│
├── 02_discovery/
│   └── INTENT_007_discovery.json      # 4-pass discovery output
│
├── 03_issue/
│   └── INTENT_007_issue.md            # Generated issue with acceptance criteria
│
├── 04_plan/
│   ├── plan_metadata.json             # Plan-level metadata
│   ├── phase_01_database.md           # Phase 1: Model verification
│   ├── phase_02_backend.md            # Phase 2: API extension
│   └── phase_03_frontend.md           # Phase 3: UI implementation
│
├── 05_packets/
│   ├── phase_01_packet.md             # Handoff packet for Phase 1
│   ├── phase_02_packet.md             # Handoff packet for Phase 2
│   └── phase_03_packet.md             # Handoff packet for Phase 3
│
├── 06_governance/
│   ├── verdict_passed.json            # Example: All checks passed
│   └── verdict_failed_gov009.json     # Example: Domain violation (NEVER)
│
├── 07_timeline/
│   └── INTENT_007_events.jsonl        # Immutable event log
│
└── config/
    ├── domains.yaml                   # Example domain registry
    ├── engine.yaml                    # Example engine config
    └── governance/
        ├── l0.yaml                    # Structural invariants
        ├── l1.yaml                    # Project policies
        └── l2.yaml                    # Advisory rules
```

---

## What Each Phase Demonstrates

### 01_intent
The raw intent as captured from user input. Note the structured format with timestamp and unique ID.

### 02_discovery
The 4-pass discovery output showing:
- **Pass 1**: Framework detection (Django, React)
- **Pass 2**: Surface discovery with model fields (AUTHORITATIVE)
- **Pass 3**: Interaction ownership binding
- **Pass 4**: Schema sufficiency check (DETERMINISTIC)
- **User Resolution**: Frontend scope disambiguation

### 03_issue
The generated issue showing:
- Backend acceptance criteria
- Frontend acceptance criteria
- Technical requirements grounded in discovery
- Files affected (traced to discovery facts)

### 04_plan
Three sequenced phases with:
- Explicit dependencies (`Depends On: Phase N`)
- Grounding sections citing discovered facts
- Files to modify vs. files that may be created
- Acceptance criteria addressed per phase
- Test specifications

### 05_packets
Self-contained handoff documents for Claude Code, Cursor, or manual implementation:
- Full context without needing access to other artifacts
- Clear scope boundaries
- Grounding information included

### 06_governance
Example verdicts showing:
- **Passed**: All GOV-001 through GOV-009 checks passed
- **Failed**: GOV-009 domain violation with `fixability: NEVER`

### 07_timeline
The immutable event log showing every action taken, with timestamps and agent attribution.

---

## Key Concepts Illustrated

### User Resolution as Type Cast

In `02_discovery`, notice the `resolution_type: "frontend_scope"` field. The user was prompted:

```
Your intent introduces new frontend UI work, but no frontend 
component files were discovered.

1. Provide a directory to scan
2. Provide a specific file path  
3. Skip frontend work
```

The user provided: `apps/frontend/components/ProjectDetailModal.tsx`

This became the **only** valid frontend target—all other options were pruned.

### Grounding Sections

Each phase includes a "Grounding" section that cites discovery facts:

```markdown
## Grounding (Existing State)
**Existing Models and Fields**:
- `ProjectTask` model exists in `apps/api/models/project.py`
- `status` field has choices: Open, In-Progress, Closed
```

The planner cannot reference files or fields not in discovery.

### Schema Sufficiency

Phase 1 demonstrates schema sufficiency checking:

```markdown
**CRITICAL**: No new model fields are needed. 
All required fields already exist per Discovery.
```

Because Pass 4 determined `migration_required: false`, the planner was blocked from proposing database migrations.

### Fixability in Action

In `06_governance/verdict_failed_gov009.json`, see how a domain violation produces:

```json
{
  "rule": "GOV-009",
  "violation": "Backend class 'TodoService' uses alias 'Todo'. Canonical domain: 'Task'",
  "fixability": "NEVER",
  "remediation": "Rename class to use canonical domain name 'Task'"
}
```

This cannot be auto-repaired—the system halts and requires source correction.

---

## Using These Examples

**To understand Archon's output format:**
Browse the artifacts in sequence (01 → 07) to see the complete flow.

**To validate your Anvil implementation:**
Use these as reference outputs. Your implementation should produce structurally similar artifacts.

**To test governance rules:**
The `06_governance` examples show both passing and failing cases.

**To create handoff packets:**
The `05_packets` examples show the self-contained format for external tool handoff.